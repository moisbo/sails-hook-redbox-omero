{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/XHRUpload.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/XHRUpload.js","mtime":1521677677000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;\n\nvar Plugin = require('../core/Plugin');\nvar cuid = require('cuid');\nvar Translator = require('../core/Translator');\nvar UppySocket = require('../core/UppySocket');\n\nvar _require = require('../core/Utils'),\n    emitSocketProgress = _require.emitSocketProgress,\n    getSocketHost = _require.getSocketHost,\n    settle = _require.settle,\n    limitPromises = _require.limitPromises;\n\nfunction buildResponseError(xhr, error) {\n  // No error message\n  if (!error) error = new Error('Upload error');\n  // Got an error message string\n  if (typeof error === 'string') error = new Error(error);\n  // Got something else\n  if (!(error instanceof Error)) {\n    error = _extends(new Error('Upload error'), { data: error });\n  }\n\n  error.request = xhr;\n  return error;\n}\n\nmodule.exports = function (_Plugin) {\n  _inherits(XHRUpload, _Plugin);\n\n  function XHRUpload(uppy, opts) {\n    _classCallCheck(this, XHRUpload);\n\n    var _this = _possibleConstructorReturn(this, _Plugin.call(this, uppy, opts));\n\n    _this.type = 'uploader';\n    _this.id = 'XHRUpload';\n    _this.title = 'XHRUpload';\n\n    var defaultLocale = {\n      strings: {\n        timedOut: 'Upload stalled for %{seconds} seconds, aborting.'\n      }\n\n      // Default options\n    };var defaultOptions = {\n      formData: true,\n      fieldName: 'files[]',\n      method: 'post',\n      metaFields: null,\n      responseUrlFieldName: 'url',\n      bundle: false,\n      headers: {},\n      locale: defaultLocale,\n      timeout: 30 * 1000,\n      limit: 0,\n      /**\n       * @typedef respObj\n       * @property {string} responseText\n       * @property {number} status\n       * @property {string} statusText\n       * @property {Object.<string, string>} headers\n       *\n       * @param {string} responseContent the response body\n       * @param {XMLHttpRequest | respObj} responseObject the response object\n       */\n      getResponseData: function getResponseData(responseContent, responseObject) {\n        var response = {};\n        try {\n          response = JSON.parse(responseContent);\n        } catch (err) {\n          console.log(err);\n        }\n\n        return response;\n      },\n\n      /**\n       *\n       * @param {string} responseContent the response body\n       * @param {XMLHttpRequest | respObj} responseObject the response object\n       */\n      getResponseError: function getResponseError(responseContent, responseObject) {\n        return new Error('Upload error');\n      }\n    };\n\n    // Merge default options with the ones set by user\n    _this.opts = _extends({}, defaultOptions, opts);\n    _this.locale = _extends({}, defaultLocale, _this.opts.locale);\n    _this.locale.strings = _extends({}, defaultLocale.strings, _this.opts.locale.strings);\n\n    // i18n\n    _this.translator = new Translator({ locale: _this.locale });\n    _this.i18n = _this.translator.translate.bind(_this.translator);\n\n    _this.handleUpload = _this.handleUpload.bind(_this);\n\n    // Simultaneous upload limiting is shared across all uploads with this plugin.\n    if (typeof _this.opts.limit === 'number' && _this.opts.limit !== 0) {\n      _this.limitUploads = limitPromises(_this.opts.limit);\n    } else {\n      _this.limitUploads = function (fn) {\n        return fn;\n      };\n    }\n\n    if (_this.opts.bundle && !_this.opts.formData) {\n      throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n    }\n    return _this;\n  }\n\n  XHRUpload.prototype.getOptions = function getOptions(file) {\n    var opts = _extends({}, this.opts, this.uppy.state.xhrUpload || {}, file.xhrUpload || {});\n    opts.headers = {};\n    _extends(opts.headers, this.opts.headers);\n    if (this.uppy.state.xhrUpload) {\n      _extends(opts.headers, this.uppy.state.xhrUpload.headers);\n    }\n    if (file.xhrUpload) {\n      _extends(opts.headers, file.xhrUpload.headers);\n    }\n\n    return opts;\n  };\n\n  // Helper to abort upload requests if there has not been any progress for `timeout` ms.\n  // Create an instance using `timer = createProgressTimeout(10000, onTimeout)`\n  // Call `timer.progress()` to signal that there has been progress of any kind.\n  // Call `timer.done()` when the upload has completed.\n\n\n  XHRUpload.prototype.createProgressTimeout = function createProgressTimeout(timeout, timeoutHandler) {\n    var uppy = this.uppy;\n    var self = this;\n    function onTimedOut() {\n      uppy.log('[XHRUpload] timed out');\n      var error = new Error(self.i18n('timedOut', { seconds: Math.ceil(timeout / 1000) }));\n      timeoutHandler(error);\n    }\n\n    var aliveTimer = null;\n    function progress() {\n      if (timeout > 0) {\n        done();\n        aliveTimer = setTimeout(onTimedOut, timeout);\n      }\n    }\n\n    function done() {\n      if (aliveTimer) {\n        clearTimeout(aliveTimer);\n        aliveTimer = null;\n      }\n    }\n\n    return {\n      progress: progress,\n      done: done\n    };\n  };\n\n  XHRUpload.prototype.createFormDataUpload = function createFormDataUpload(file, opts) {\n    var formPost = new FormData();\n\n    var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields\n    // Send along all fields by default.\n    : Object.keys(file.meta);\n    metaFields.forEach(function (item) {\n      formPost.append(item, file.meta[item]);\n    });\n\n    formPost.append(opts.fieldName, file.data);\n\n    return formPost;\n  };\n\n  XHRUpload.prototype.createBareUpload = function createBareUpload(file, opts) {\n    return file.data;\n  };\n\n  XHRUpload.prototype.upload = function upload(file, current, total) {\n    var _this2 = this;\n\n    var opts = this.getOptions(file);\n\n    this.uppy.log('uploading ' + current + ' of ' + total);\n    return new _Promise(function (resolve, reject) {\n      var data = opts.formData ? _this2.createFormDataUpload(file, opts) : _this2.createBareUpload(file, opts);\n\n      var timer = _this2.createProgressTimeout(opts.timeout, function (error) {\n        xhr.abort();\n        _this2.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n\n      var xhr = new XMLHttpRequest();\n      var id = cuid();\n\n      xhr.upload.addEventListener('loadstart', function (ev) {\n        _this2.uppy.log('[XHRUpload] ' + id + ' started');\n        // Begin checking for timeouts when loading starts.\n        timer.progress();\n      });\n\n      xhr.upload.addEventListener('progress', function (ev) {\n        _this2.uppy.log('[XHRUpload] ' + id + ' progress: ' + ev.loaded + ' / ' + ev.total);\n        timer.progress();\n\n        if (ev.lengthComputable) {\n          _this2.uppy.emit('upload-progress', file, {\n            uploader: _this2,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n\n      xhr.addEventListener('load', function (ev) {\n        _this2.uppy.log('[XHRUpload] ' + id + ' finished');\n        timer.done();\n\n        if (ev.target.status >= 200 && ev.target.status < 300) {\n          var body = opts.getResponseData(xhr.responseText, xhr);\n          var uploadURL = body[opts.responseUrlFieldName];\n\n          var response = {\n            status: ev.target.status,\n            body: body,\n            uploadURL: uploadURL\n          };\n\n          _this2.uppy.setFileState(file.id, { response: response });\n\n          _this2.uppy.emit('upload-success', file, body, uploadURL);\n\n          if (uploadURL) {\n            _this2.uppy.log('Download ' + file.name + ' from ' + file.uploadURL);\n          }\n\n          return resolve(file);\n        } else {\n          var _body = opts.getResponseData(xhr.responseText, xhr);\n          var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n\n          var _response = {\n            status: ev.target.status,\n            body: _body\n          };\n\n          _this2.uppy.setFileState(file.id, { response: _response });\n\n          _this2.uppy.emit('upload-error', file, error);\n          return reject(error);\n        }\n      });\n\n      xhr.addEventListener('error', function (ev) {\n        _this2.uppy.log('[XHRUpload] ' + id + ' errored');\n        timer.done();\n\n        var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        _this2.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true);\n\n      Object.keys(opts.headers).forEach(function (header) {\n        xhr.setRequestHeader(header, opts.headers[header]);\n      });\n\n      xhr.send(data);\n\n      _this2.uppy.on('file-removed', function (removedFile) {\n        if (removedFile.id === file.id) {\n          timer.done();\n          xhr.abort();\n        }\n      });\n\n      _this2.uppy.on('upload-cancel', function (fileID) {\n        if (fileID === file.id) {\n          timer.done();\n          xhr.abort();\n        }\n      });\n\n      _this2.uppy.on('cancel-all', function () {\n        // const files = this.uppy.getState().files\n        // if (!files[file.id]) return\n        xhr.abort();\n      });\n    });\n  };\n\n  XHRUpload.prototype.uploadRemote = function uploadRemote(file, current, total) {\n    var _this3 = this;\n\n    var opts = this.getOptions(file);\n    return new _Promise(function (resolve, reject) {\n      var fields = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields\n      // Send along all fields by default.\n      : Object.keys(file.meta);\n\n      metaFields.forEach(function (name) {\n        fields[name] = file.meta[name];\n      });\n\n      fetch(file.remote.url, {\n        method: 'post',\n        credentials: 'include',\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(_extends({}, file.remote.body, {\n          endpoint: opts.endpoint,\n          size: file.data.size,\n          fieldname: opts.fieldName,\n          metadata: fields,\n          headers: opts.headers\n        }))\n      }).then(function (res) {\n        if (res.status < 200 && res.status > 300) {\n          return reject(res.statusText);\n        }\n\n        res.json().then(function (data) {\n          var token = data.token;\n          var host = getSocketHost(file.remote.host);\n          var socket = new UppySocket({ target: host + '/api/' + token });\n\n          socket.on('progress', function (progressData) {\n            return emitSocketProgress(_this3, progressData, file);\n          });\n\n          socket.on('success', function (data) {\n            var resp = opts.getResponseData(data.response.responseText, data.response);\n            var uploadURL = resp[opts.responseUrlFieldName];\n            _this3.uppy.emit('upload-success', file, resp, uploadURL);\n            socket.close();\n            return resolve();\n          });\n\n          socket.on('error', function (errData) {\n            var resp = errData.response;\n            var error = resp ? opts.getResponseError(resp.responseText, resp) : new Error(errData.error);\n            _this3.uppy.emit('upload-error', file, error);\n            reject(new Error(errData.error));\n          });\n        });\n      });\n    });\n  };\n\n  XHRUpload.prototype.uploadBundle = function uploadBundle(files) {\n    var _this4 = this;\n\n    return new _Promise(function (resolve, reject) {\n      var endpoint = _this4.opts.endpoint;\n      var method = _this4.opts.method;\n\n      var formData = new FormData();\n      files.forEach(function (file, i) {\n        var opts = _this4.getOptions(file);\n        formData.append(opts.fieldName, file.data);\n      });\n\n      var xhr = new XMLHttpRequest();\n\n      var timer = _this4.createProgressTimeout(_this4.opts.timeout, function (error) {\n        xhr.abort();\n        emitError(error);\n        reject(error);\n      });\n\n      var emitError = function emitError(error) {\n        files.forEach(function (file) {\n          _this4.uppy.emit('upload-error', file, error);\n        });\n      };\n\n      xhr.upload.addEventListener('loadstart', function (ev) {\n        _this4.uppy.log('[XHRUpload] started uploading bundle');\n        timer.progress();\n      });\n\n      xhr.upload.addEventListener('progress', function (ev) {\n        timer.progress();\n\n        if (!ev.lengthComputable) return;\n\n        files.forEach(function (file) {\n          _this4.uppy.emit('upload-progress', file, {\n            uploader: _this4,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        });\n      });\n\n      xhr.addEventListener('load', function (ev) {\n        timer.done();\n\n        if (ev.target.status >= 200 && ev.target.status < 300) {\n          var resp = _this4.opts.getResponseData(xhr.responseText, xhr);\n          files.forEach(function (file) {\n            _this4.uppy.emit('upload-success', file, resp);\n          });\n          return resolve();\n        }\n\n        var error = _this4.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        error.request = xhr;\n        emitError(error);\n        return reject(error);\n      });\n\n      xhr.addEventListener('error', function (ev) {\n        timer.done();\n\n        var error = _this4.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        emitError(error);\n        return reject(error);\n      });\n\n      _this4.uppy.on('cancel-all', function () {\n        xhr.abort();\n      });\n\n      xhr.open(method.toUpperCase(), endpoint, true);\n\n      Object.keys(_this4.opts.headers).forEach(function (header) {\n        xhr.setRequestHeader(header, _this4.opts.headers[header]);\n      });\n\n      xhr.send(formData);\n\n      files.forEach(function (file) {\n        _this4.uppy.emit('upload-started', file);\n      });\n    });\n  };\n\n  XHRUpload.prototype.uploadFiles = function uploadFiles(files) {\n    var _this5 = this;\n\n    var actions = files.map(function (file, i) {\n      var current = parseInt(i, 10) + 1;\n      var total = files.length;\n\n      if (file.error) {\n        return function () {\n          return _Promise.reject(new Error(file.error));\n        };\n      } else if (file.isRemote) {\n        // We emit upload-started here, so that it's also emitted for files\n        // that have to wait due to the `limit` option.\n        _this5.uppy.emit('upload-started', file);\n        return _this5.uploadRemote.bind(_this5, file, current, total);\n      } else {\n        _this5.uppy.emit('upload-started', file);\n        return _this5.upload.bind(_this5, file, current, total);\n      }\n    });\n\n    var promises = actions.map(function (action) {\n      var limitedAction = _this5.limitUploads(action);\n      return limitedAction();\n    });\n\n    return settle(promises);\n  };\n\n  XHRUpload.prototype.handleUpload = function handleUpload(fileIDs) {\n    var _this6 = this;\n\n    if (fileIDs.length === 0) {\n      this.uppy.log('[XHRUpload] No files to upload!');\n      return _Promise.resolve();\n    }\n\n    this.uppy.log('[XHRUpload] Uploading...');\n    var files = fileIDs.map(function (fileID) {\n      return _this6.uppy.getFile(fileID);\n    });\n\n    if (this.opts.bundle) {\n      return this.uploadBundle(files);\n    }\n\n    return this.uploadFiles(files).then(function () {\n      return null;\n    });\n  };\n\n  XHRUpload.prototype.install = function install() {\n    this.uppy.addUploader(this.handleUpload);\n  };\n\n  XHRUpload.prototype.uninstall = function uninstall() {\n    this.uppy.removeUploader(this.handleUpload);\n  };\n\n  return XHRUpload;\n}(Plugin);\n//# sourceMappingURL=XHRUpload.js.map",null]}