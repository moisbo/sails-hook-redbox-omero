{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/tus-js-client/lib.es5/upload.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/tus-js-client/lib.es5/upload.js","mtime":1523026673000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// Generated by Babel\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window */\n\n\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fingerprint = require(\"./fingerprint\");\n\nvar _fingerprint2 = _interopRequireDefault(_fingerprint);\n\nvar _error = require(\"./error\");\n\nvar _error2 = _interopRequireDefault(_error);\n\nvar _extend = require(\"extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _request = require(\"./node/request\");\n\nvar _source = require(\"./node/source\");\n\nvar _base = require(\"./node/base64\");\n\nvar Base64 = _interopRequireWildcard(_base);\n\nvar _storage = require(\"./node/storage\");\n\nvar Storage = _interopRequireWildcard(_storage);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultOptions = {\n  endpoint: null,\n  fingerprint: _fingerprint2.default,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false\n};\n\nvar Upload = function () {\n  function Upload(file, options) {\n    _classCallCheck(this, Upload);\n\n    this.options = (0, _extend2.default)(true, {}, defaultOptions, options);\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The underlying XHR object for the current PATCH request\n    this._xhr = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The current count of attempts which have been made. Null indicates none.\n    this._retryAttempt = 0;\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null;\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0;\n  }\n\n  _createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n        return;\n      }\n\n      var source = this._source = (0, _source.getSource)(file, this.options.chunkSize);\n\n      // Firstly, check if the caller has supplied a manual upload size or else\n      // we will use the calculated size by the source object.\n      if (this.options.uploadSize != null) {\n        var size = +this.options.uploadSize;\n        if (isNaN(size)) {\n          throw new Error(\"tus: cannot convert `uploadSize` option into a number\");\n        }\n\n        this._size = size;\n      } else {\n        var size = source.size;\n\n        // The size property will be null if we cannot calculate the file's size,\n        // for example if you handle a stream.\n        if (size == null) {\n          throw new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\");\n        }\n\n        this._size = size;\n      }\n\n      var retryDelays = this.options.retryDelays;\n      if (retryDelays != null) {\n        if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n          throw new Error(\"tus: the `retryDelays` option must either be an array or null\");\n        } else {\n          (function () {\n            var errorCallback = _this.options.onError;\n            _this.options.onError = function (err) {\n              // Restore the original error callback which may have been set.\n              _this.options.onError = errorCallback;\n\n              // We will reset the attempt counter if\n              // - we were already able to connect to the server (offset != null) and\n              // - we were able to upload a small chunk of data to the server\n              var shouldResetDelays = _this._offset != null && _this._offset > _this._offsetBeforeRetry;\n              if (shouldResetDelays) {\n                _this._retryAttempt = 0;\n              }\n\n              var isOnline = true;\n              if (typeof window !== \"undefined\" && \"navigator\" in window && window.navigator.onLine === false) {\n                isOnline = false;\n              }\n\n              // We only attempt a retry if\n              // - we didn't exceed the maxium number of retries, yet, and\n              // - this error was caused by a request or it's response and\n              // - the error is not a client error (status 4xx) and\n              // - the browser does not indicate that we are offline\n              var shouldRetry = _this._retryAttempt < retryDelays.length && err.originalRequest != null && !inStatusCategory(err.originalRequest.status, 400) && isOnline;\n\n              if (!shouldRetry) {\n                _this._emitError(err);\n                return;\n              }\n\n              var delay = retryDelays[_this._retryAttempt++];\n\n              _this._offsetBeforeRetry = _this._offset;\n              _this.options.uploadUrl = _this.url;\n\n              _this._retryTimeout = setTimeout(function () {\n                _this.start();\n              }, delay);\n            };\n          })();\n        }\n      }\n\n      // Reset the aborted flag when the upload is started or else the\n      // _startUpload will stop before sending a request if the upload has been\n      // aborted previously.\n      this._aborted = false;\n\n      // The upload had been started previously and we should reuse this URL.\n      if (this.url != null) {\n        this._resumeUpload();\n        return;\n      }\n\n      // A URL has manually been specified, so we try to resume\n      if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n      }\n\n      // Try to find the endpoint for the file in the storage\n      if (this.options.resume) {\n        this._fingerprint = this.options.fingerprint(file, this.options);\n        var resumedUrl = Storage.getItem(this._fingerprint);\n\n        if (resumedUrl != null) {\n          this.url = resumedUrl;\n          this._resumeUpload();\n          return;\n        }\n      }\n\n      // An upload has not started for the file yet, so we start a new one\n      this._createUpload();\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (this._xhr !== null) {\n        this._xhr.abort();\n        this._source.close();\n        this._aborted = true;\n      }\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n    }\n  }, {\n    key: \"_emitXhrError\",\n    value: function _emitXhrError(xhr, err, causingErr) {\n      this._emitError(new _error2.default(err, causingErr, xhr));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      if (typeof this.options.onError === \"function\") {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (typeof this.options.onSuccess === \"function\") {\n        this.options.onSuccess();\n      }\n    }\n\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     * @param  {number} bytesSent  Number of bytes sent to the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === \"function\") {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param  {number} chunkSize  Size of the chunk that was accepted by the\n     *                             server.\n     * @param  {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === \"function\") {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n\n    /**\n     * Set the headers used in the request and the withCredentials property\n     * as defined in the options\n     *\n     * @param {XMLHttpRequest} xhr\n     */\n\n  }, {\n    key: \"_setupXHR\",\n    value: function _setupXHR(xhr) {\n      this._xhr = xhr;\n\n      xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n      var headers = this.options.headers;\n\n      for (var name in headers) {\n        xhr.setRequestHeader(name, headers[name]);\n      }\n\n      xhr.withCredentials = this.options.withCredentials;\n    }\n\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this2 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"POST\", this.options.endpoint, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this2._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n          return;\n        }\n\n        var location = xhr.getResponseHeader(\"Location\");\n        if (location == null) {\n          _this2._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n          return;\n        }\n\n        _this2.url = (0, _request.resolveUrl)(_this2.options.endpoint, location);\n\n        if (_this2._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this2._emitSuccess();\n          _this2._source.close();\n          return;\n        }\n\n        if (_this2.options.resume) {\n          Storage.setItem(_this2._fingerprint, _this2.url);\n        }\n\n        _this2._offset = 0;\n        _this2._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this2._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      xhr.setRequestHeader(\"Upload-Length\", this._size);\n\n      // Add metadata if values have been added\n      var metadata = encodeMetadata(this.options.metadata);\n      if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n      }\n\n      xhr.send(null);\n    }\n\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this3 = this;\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"HEAD\", this.url, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          if (_this3.options.resume && inStatusCategory(xhr.status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            Storage.removeItem(_this3._fingerprint);\n          }\n\n          // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n          if (xhr.status === 423) {\n            _this3._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n            return;\n          }\n\n          if (!_this3.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this3._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n            return;\n          }\n\n          // Try to create a new upload\n          _this3.url = null;\n          _this3._createUpload();\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n        if (isNaN(offset)) {\n          _this3._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n          return;\n        }\n\n        var length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n        if (isNaN(length)) {\n          _this3._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n          return;\n        }\n\n        // Upload has already been completed and we do not need to send additional\n        // data to the server\n        if (offset === length) {\n          _this3._emitProgress(length, length);\n          _this3._emitSuccess();\n          return;\n        }\n\n        _this3._offset = offset;\n        _this3._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this3._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      xhr.send(null);\n    }\n\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startUpload\",\n    value: function _startUpload() {\n      var _this4 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n\n      // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n      if (this.options.overridePatchMethod) {\n        xhr.open(\"POST\", this.url, true);\n        xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n      } else {\n        xhr.open(\"PATCH\", this.url, true);\n      }\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n        if (isNaN(offset)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n          return;\n        }\n\n        _this4._emitProgress(offset, _this4._size);\n        _this4._emitChunkComplete(offset - _this4._offset, offset, _this4._size);\n\n        _this4._offset = offset;\n\n        if (offset == _this4._size) {\n          if (_this4.options.removeFingerprintOnSuccess && _this4.options.resume) {\n            // Remove stored fingerprint and corresponding endpoint. This causes\n            // new upload of the same file must be treated as a different file.\n            Storage.removeItem(_this4._fingerprint);\n          }\n\n          // Yay, finally done :)\n          _this4._emitSuccess();\n          _this4._source.close();\n          return;\n        }\n\n        _this4._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this4._aborted) {\n          return;\n        }\n\n        _this4._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + _this4._offset), err);\n      };\n\n      // Test support for progress events before attaching an event listener\n      if (\"upload\" in xhr) {\n        xhr.upload.onprogress = function (e) {\n          if (!e.lengthComputable) {\n            return;\n          }\n\n          _this4._emitProgress(start + e.loaded, _this4._size);\n        };\n      }\n\n      this._setupXHR(xhr);\n\n      xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n      xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n\n      // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n      if (end === Infinity || end > this._size) {\n        end = this._size;\n      }\n\n      xhr.send(this._source.slice(start, end));\n\n      // Emit an progress event when a new chunk begins being uploaded.\n      this._emitProgress(this._offset, this._size);\n    }\n  }]);\n\n  return Upload;\n}();\n\nfunction encodeMetadata(metadata) {\n  if (!Base64.isSupported) {\n    return \"\";\n  }\n\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(key + \" \" + Base64.encode(metadata[key]));\n  }\n\n  return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexports.default = Upload;",null]}