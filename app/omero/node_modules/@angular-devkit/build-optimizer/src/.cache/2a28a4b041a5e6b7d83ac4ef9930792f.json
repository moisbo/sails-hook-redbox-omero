{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/Webcam/index.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/Webcam/index.js","mtime":1521677677000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;\n\nvar _require = require('preact'),\n    h = _require.h;\n\nvar Plugin = require('../../core/Plugin');\nvar Translator = require('../../core/Translator');\n\nvar _require2 = require('../../core/Utils'),\n    getFileTypeExtension = _require2.getFileTypeExtension,\n    canvasToBlob = _require2.canvasToBlob;\n\nvar supportsMediaRecorder = require('./supportsMediaRecorder');\nvar WebcamIcon = require('./WebcamIcon');\nvar CameraScreen = require('./CameraScreen');\nvar PermissionsScreen = require('./PermissionsScreen');\n\n// Setup getUserMedia, with polyfill for older browsers\n// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\nfunction getMediaDevices() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices;\n  }\n\n  var _getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;\n  if (!_getUserMedia) {\n    return null;\n  }\n\n  return {\n    getUserMedia: function getUserMedia(opts) {\n      return new _Promise(function (resolve, reject) {\n        _getUserMedia.call(navigator, opts, resolve, reject);\n      });\n    }\n  };\n}\n\n/**\n * Webcam\n */\nmodule.exports = function (_Plugin) {\n  _inherits(Webcam, _Plugin);\n\n  function Webcam(uppy, opts) {\n    _classCallCheck(this, Webcam);\n\n    var _this = _possibleConstructorReturn(this, _Plugin.call(this, uppy, opts));\n\n    _this.mediaDevices = getMediaDevices();\n    _this.supportsUserMedia = !!_this.mediaDevices;\n    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';\n    _this.id = _this.opts.id || 'Webcam';\n    _this.title = 'Webcam';\n    _this.type = 'acquirer';\n    _this.icon = WebcamIcon;\n\n    var defaultLocale = {\n      strings: {\n        smile: 'Smile!'\n      }\n\n      // set default options\n    };var defaultOptions = {\n      onBeforeSnapshot: function onBeforeSnapshot() {\n        return _Promise.resolve();\n      },\n      countdown: false,\n      locale: defaultLocale,\n      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],\n      mirror: true,\n      facingMode: 'user'\n\n      // merge default options with the ones set by user\n    };_this.opts = _extends({}, defaultOptions, opts);\n\n    _this.locale = _extends({}, defaultLocale, _this.opts.locale);\n    _this.locale.strings = _extends({}, defaultLocale.strings, _this.opts.locale.strings);\n\n    // i18n\n    _this.translator = new Translator({ locale: _this.locale });\n    _this.i18n = _this.translator.translate.bind(_this.translator);\n\n    _this.install = _this.install.bind(_this);\n    _this.setPluginState = _this.setPluginState.bind(_this);\n\n    _this.render = _this.render.bind(_this);\n\n    // Camera controls\n    _this.start = _this.start.bind(_this);\n    _this.stop = _this.stop.bind(_this);\n    _this.takeSnapshot = _this.takeSnapshot.bind(_this);\n    _this.startRecording = _this.startRecording.bind(_this);\n    _this.stopRecording = _this.stopRecording.bind(_this);\n    _this.oneTwoThreeSmile = _this.oneTwoThreeSmile.bind(_this);\n    _this.focus = _this.focus.bind(_this);\n\n    _this.webcamActive = false;\n\n    if (_this.opts.countdown) {\n      _this.opts.onBeforeSnapshot = _this.oneTwoThreeSmile;\n    }\n    return _this;\n  }\n\n  Webcam.prototype.isSupported = function isSupported() {\n    return !!this.mediaDevices;\n  };\n\n  Webcam.prototype.getConstraints = function getConstraints() {\n    var acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;\n    var acceptsVideo = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1;\n\n    return {\n      audio: acceptsAudio,\n      video: acceptsVideo ? { facingMode: this.opts.facingMode } : false\n    };\n  };\n\n  Webcam.prototype.start = function start() {\n    var _this2 = this;\n\n    if (!this.isSupported()) {\n      return _Promise.reject(new Error('Webcam access not supported'));\n    }\n\n    this.webcamActive = true;\n\n    var constraints = this.getConstraints();\n\n    // ask user for access to their camera\n    return this.mediaDevices.getUserMedia(constraints).then(function (stream) {\n      _this2.stream = stream;\n      // this.streamSrc = URL.createObjectURL(this.stream)\n      _this2.setPluginState({\n        cameraReady: true\n      });\n    }).catch(function (err) {\n      _this2.setPluginState({\n        cameraError: err\n      });\n    });\n  };\n\n  Webcam.prototype.startRecording = function startRecording() {\n    var _this3 = this;\n\n    // TODO We can check here if any of the mime types listed in the\n    // mimeToExtensions map in Utils.js are supported, and prefer to use one of\n    // those.\n    // Right now we let the browser pick a type that it deems appropriate.\n    this.recorder = new MediaRecorder(this.stream);\n    this.recordingChunks = [];\n    this.recorder.addEventListener('dataavailable', function (event) {\n      _this3.recordingChunks.push(event.data);\n    });\n    this.recorder.start();\n\n    this.setPluginState({\n      isRecording: true\n    });\n  };\n\n  Webcam.prototype.stopRecording = function stopRecording() {\n    var _this4 = this;\n\n    var stopped = new _Promise(function (resolve, reject) {\n      _this4.recorder.addEventListener('stop', function () {\n        resolve();\n      });\n      _this4.recorder.stop();\n    });\n\n    return stopped.then(function () {\n      _this4.setPluginState({\n        isRecording: false\n      });\n      return _this4.getVideo();\n    }).then(function (file) {\n      return _this4.uppy.addFile(file);\n    }).then(function () {\n      _this4.recordingChunks = null;\n      _this4.recorder = null;\n      var dashboard = _this4.uppy.getPlugin('Dashboard');\n      if (dashboard) dashboard.hideAllPanels();\n    }, function (error) {\n      _this4.recordingChunks = null;\n      _this4.recorder = null;\n      throw error;\n    });\n  };\n\n  Webcam.prototype.stop = function stop() {\n    this.stream.getAudioTracks().forEach(function (track) {\n      track.stop();\n    });\n    this.stream.getVideoTracks().forEach(function (track) {\n      track.stop();\n    });\n    this.webcamActive = false;\n    this.stream = null;\n  };\n\n  Webcam.prototype.getVideoElement = function getVideoElement() {\n    return this.el.querySelector('.uppy-Webcam-video');\n  };\n\n  Webcam.prototype.oneTwoThreeSmile = function oneTwoThreeSmile() {\n    var _this5 = this;\n\n    return new _Promise(function (resolve, reject) {\n      var count = _this5.opts.countdown;\n\n      var countDown = setInterval(function () {\n        if (!_this5.webcamActive) {\n          clearInterval(countDown);\n          _this5.captureInProgress = false;\n          return reject(new Error('Webcam is not active'));\n        }\n\n        if (count > 0) {\n          _this5.uppy.info(count + '...', 'warning', 800);\n          count--;\n        } else {\n          clearInterval(countDown);\n          _this5.uppy.info(_this5.i18n('smile'), 'success', 1500);\n          setTimeout(function () {\n            return resolve();\n          }, 1500);\n        }\n      }, 1000);\n    });\n  };\n\n  Webcam.prototype.takeSnapshot = function takeSnapshot() {\n    var _this6 = this;\n\n    if (this.captureInProgress) return;\n    this.captureInProgress = true;\n\n    this.opts.onBeforeSnapshot().catch(function (err) {\n      var message = (typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object' ? err.message : err;\n      _this6.uppy.info(message, 'error', 5000);\n      return _Promise.reject(new Error('onBeforeSnapshot: ' + message));\n    }).then(function () {\n      return _this6.getImage();\n    }).then(function (tagFile) {\n      _this6.captureInProgress = false;\n      var dashboard = _this6.uppy.getPlugin('Dashboard');\n      if (dashboard) dashboard.hideAllPanels();\n      return _this6.uppy.addFile(tagFile).catch(function () {\n        // Ignore\n      });\n    }, function (error) {\n      _this6.captureInProgress = false;\n      throw error;\n    });\n  };\n\n  Webcam.prototype.getImage = function getImage() {\n    var _this7 = this;\n\n    var video = this.getVideoElement();\n    if (!video) {\n      return _Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));\n    }\n\n    var name = 'webcam-' + Date.now() + '.jpg';\n    var mimeType = 'image/jpeg';\n\n    var width = video.videoWidth;\n    var height = video.videoHeight;\n\n    // const scaleH = this.opts.mirror ? -1 : 1 // Set horizontal scale to -1 if flip horizontal\n    // const scaleV = 1\n    // const posX = this.opts.mirror ? width * -1 : 0 // Set x position to -100% if flip horizontal\n    // const posY = 0\n\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0);\n    // ctx.save() // Save the current state\n    // ctx.scale(scaleH, scaleV) // Set scale to flip the image\n    // ctx.drawImage(video, posX, posY, width, height) // draw the image\n    // ctx.restore() // Restore the last saved state\n\n    return canvasToBlob(canvas, mimeType).then(function (blob) {\n      return {\n        source: _this7.id,\n        name: name,\n        data: new File([blob], name, { type: mimeType }),\n        type: mimeType\n      };\n    });\n  };\n\n  Webcam.prototype.getVideo = function getVideo() {\n    var mimeType = this.recordingChunks[0].type;\n    var fileExtension = getFileTypeExtension(mimeType);\n\n    if (!fileExtension) {\n      return _Promise.reject(new Error('Could not retrieve recording: Unsupported media type \"' + mimeType + '\"'));\n    }\n\n    var name = 'webcam-' + Date.now() + '.' + fileExtension;\n    var blob = new Blob(this.recordingChunks, { type: mimeType });\n    var file = {\n      source: this.id,\n      name: name,\n      data: new File([blob], name, { type: mimeType }),\n      type: mimeType\n    };\n\n    return _Promise.resolve(file);\n  };\n\n  Webcam.prototype.focus = function focus() {\n    var _this8 = this;\n\n    if (this.opts.countdown) return;\n    setTimeout(function () {\n      _this8.uppy.info(_this8.i18n('smile'), 'success', 1500);\n    }, 1000);\n  };\n\n  Webcam.prototype.render = function render(state) {\n    if (!this.webcamActive) {\n      this.start();\n    }\n\n    var webcamState = this.getPluginState();\n\n    if (!webcamState.cameraReady) {\n      return PermissionsScreen(webcamState);\n    }\n\n    return h(CameraScreen, _extends({}, webcamState, {\n      onSnapshot: this.takeSnapshot,\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onFocus: this.focus,\n      onStop: this.stop,\n      modes: this.opts.modes,\n      supportsRecording: supportsMediaRecorder(),\n      recording: webcamState.isRecording,\n      mirror: this.opts.mirror,\n      src: this.stream\n    }));\n  };\n\n  Webcam.prototype.install = function install() {\n    this.setPluginState({\n      cameraReady: false\n    });\n\n    var target = this.opts.target;\n    if (target) {\n      this.mount(target, this);\n    }\n  };\n\n  Webcam.prototype.uninstall = function uninstall() {\n    if (this.stream) {\n      this.stop();\n    }\n\n    this.unmount();\n  };\n\n  return Webcam;\n}(Plugin);\n//# sourceMappingURL=index.js.map",null]}