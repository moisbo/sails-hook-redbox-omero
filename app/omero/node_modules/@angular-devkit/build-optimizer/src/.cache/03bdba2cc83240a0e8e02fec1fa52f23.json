{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/Transloadit/index.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/Transloadit/index.js","mtime":1521677676000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;\n\nvar Translator = require('../../core/Translator');\nvar Plugin = require('../../core/Plugin');\nvar Tus = require('../Tus');\nvar Client = require('./Client');\nvar StatusSocket = require('./Socket');\n\nfunction defaultGetAssemblyOptions(file, options) {\n  return {\n    params: options.params,\n    signature: options.signature,\n    fields: options.fields\n  };\n}\n\n/**\n * Upload files to Transloadit using Tus.\n */\nmodule.exports = function (_Plugin) {\n  _inherits(Transloadit, _Plugin);\n\n  function Transloadit(uppy, opts) {\n    _classCallCheck(this, Transloadit);\n\n    var _this = _possibleConstructorReturn(this, _Plugin.call(this, uppy, opts));\n\n    _this.type = 'uploader';\n    _this.id = 'Transloadit';\n    _this.title = 'Transloadit';\n\n    var defaultLocale = {\n      strings: {\n        creatingAssembly: 'Preparing upload...',\n        creatingAssemblyFailed: 'Transloadit: Could not create Assembly',\n        encoding: 'Encoding...'\n      }\n    };\n\n    var defaultOptions = {\n      service: 'https://api2.transloadit.com',\n      waitForEncoding: false,\n      waitForMetadata: false,\n      alwaysRunAssembly: false,\n      importFromUploadURLs: false,\n      signature: null,\n      params: null,\n      fields: {},\n      getAssemblyOptions: defaultGetAssemblyOptions,\n      locale: defaultLocale\n    };\n\n    _this.opts = _extends({}, defaultOptions, opts);\n\n    _this.locale = _extends({}, defaultLocale, _this.opts.locale);\n    _this.locale.strings = _extends({}, defaultLocale.strings, _this.opts.locale.strings);\n\n    _this.translator = new Translator({ locale: _this.locale });\n    _this.i18n = _this.translator.translate.bind(_this.translator);\n\n    _this.prepareUpload = _this.prepareUpload.bind(_this);\n    _this.afterUpload = _this.afterUpload.bind(_this);\n    _this.onFileUploadURLAvailable = _this.onFileUploadURLAvailable.bind(_this);\n    _this.onRestored = _this.onRestored.bind(_this);\n    _this.getPersistentData = _this.getPersistentData.bind(_this);\n\n    if (_this.opts.params) {\n      _this.validateParams(_this.opts.params);\n    }\n\n    _this.client = new Client({\n      service: _this.opts.service\n    });\n    _this.sockets = {};\n    return _this;\n  }\n\n  Transloadit.prototype.validateParams = function validateParams(params) {\n    if (!params) {\n      throw new Error('Transloadit: The `params` option is required.');\n    }\n\n    if (typeof params === 'string') {\n      try {\n        params = JSON.parse(params);\n      } catch (err) {\n        // Tell the user that this is not an Uppy bug!\n        err.message = 'Transloadit: The `params` option is a malformed JSON string: ' + err.message;\n        throw err;\n      }\n    }\n\n    if (!params.auth || !params.auth.key) {\n      throw new Error('Transloadit: The `params.auth.key` option is required. ' + 'You can find your Transloadit API key at https://transloadit.com/accounts/credentials.');\n    }\n  };\n\n  Transloadit.prototype.getAssemblyOptions = function getAssemblyOptions(fileIDs) {\n    var _this2 = this;\n\n    var options = this.opts;\n\n    var normalizeAssemblyOptions = function normalizeAssemblyOptions(file, assemblyOptions) {\n      if (Array.isArray(assemblyOptions.fields)) {\n        var fieldNames = assemblyOptions.fields;\n        assemblyOptions.fields = {};\n        fieldNames.forEach(function (fieldName) {\n          assemblyOptions.fields[fieldName] = file.meta[fieldName];\n        });\n      }\n      if (!assemblyOptions.fields) {\n        assemblyOptions.fields = {};\n      }\n      return assemblyOptions;\n    };\n\n    return _Promise.all(fileIDs.map(function (fileID) {\n      var file = _this2.uppy.getFile(fileID);\n      var promise = _Promise.resolve().then(function () {\n        return options.getAssemblyOptions(file, options);\n      }).then(function (assemblyOptions) {\n        return normalizeAssemblyOptions(file, assemblyOptions);\n      });\n      return promise.then(function (assemblyOptions) {\n        _this2.validateParams(assemblyOptions.params);\n\n        return {\n          fileIDs: [fileID],\n          options: assemblyOptions\n        };\n      });\n    }));\n  };\n\n  Transloadit.prototype.dedupeAssemblyOptions = function dedupeAssemblyOptions(list) {\n    var dedupeMap = Object.create(null);\n    list.forEach(function (_ref) {\n      var fileIDs = _ref.fileIDs,\n          options = _ref.options;\n\n      var id = JSON.stringify(options);\n      if (dedupeMap[id]) {\n        var _dedupeMap$id$fileIDs;\n\n        (_dedupeMap$id$fileIDs = dedupeMap[id].fileIDs).push.apply(_dedupeMap$id$fileIDs, fileIDs);\n      } else {\n        dedupeMap[id] = {\n          options: options,\n          fileIDs: [].concat(fileIDs)\n        };\n      }\n    });\n\n    return Object.keys(dedupeMap).map(function (id) {\n      return dedupeMap[id];\n    });\n  };\n\n  Transloadit.prototype.createAssembly = function createAssembly(fileIDs, uploadID, options) {\n    var _this3 = this;\n\n    var pluginOptions = this.opts;\n\n    this.uppy.log('[Transloadit] create Assembly');\n\n    return this.client.createAssembly({\n      params: options.params,\n      fields: options.fields,\n      expectedFiles: fileIDs.length,\n      signature: options.signature\n    }).then(function (assembly) {\n      var _extends2, _extends3;\n\n      // Store the list of assemblies related to this upload.\n      var state = _this3.getPluginState();\n      var assemblyList = state.uploadsAssemblies[uploadID];\n      var uploadsAssemblies = _extends({}, state.uploadsAssemblies, (_extends2 = {}, _extends2[uploadID] = assemblyList.concat([assembly.assembly_id]), _extends2));\n\n      _this3.setPluginState({\n        assemblies: _extends(state.assemblies, (_extends3 = {}, _extends3[assembly.assembly_id] = assembly, _extends3)),\n        uploadsAssemblies: uploadsAssemblies\n      });\n\n      function attachAssemblyMetadata(file, assembly) {\n        // Attach meta parameters for the Tus plugin. See:\n        // https://github.com/tus/tusd/wiki/Uploading-to-Transloadit-using-tus#uploading-using-tus\n        var tlMeta = {\n          assembly_url: assembly.assembly_url,\n          filename: file.name,\n          fieldname: 'file'\n        };\n        var meta = _extends({}, file.meta, tlMeta);\n        // Add assembly-specific Tus endpoint.\n        var tus = _extends({}, file.tus, {\n          endpoint: assembly.tus_url\n        });\n\n        // Set uppy server location.\n        // we only add this, if 'file' has the attribute remote, because\n        // this is the criteria to identify remote files. If we add it without\n        // the check, then the file automatically becomes a remote file.\n        // @TODO: this is quite hacky. Please fix this later\n        var remote = void 0;\n        if (file.remote) {\n          var newHost = assembly.uppyserver_url;\n          // remove tailing slash\n          if (newHost.endsWith('/')) {\n            newHost = newHost.slice(0, -1);\n          }\n          var path = file.remote.url.replace(file.remote.host, '');\n          // remove leading slash\n          if (path.startsWith('/')) {\n            path = path.slice(1);\n          }\n          remote = _extends({}, file.remote, {\n            host: newHost,\n            url: newHost + '/' + path\n          });\n        }\n\n        var transloadit = {\n          assembly: assembly.assembly_id\n        };\n\n        var newFile = _extends({}, file, { transloadit: transloadit });\n        // Only configure the Tus plugin if we are uploading straight to Transloadit (the default).\n        if (!pluginOptions.importFromUploadURLs) {\n          _extends(newFile, { meta: meta, tus: tus, remote: remote });\n        }\n        return newFile;\n      }\n\n      var files = _extends({}, _this3.uppy.state.files);\n      fileIDs.forEach(function (id) {\n        files[id] = attachAssemblyMetadata(files[id], assembly);\n      });\n\n      _this3.uppy.setState({ files: files });\n\n      _this3.uppy.emit('transloadit:assembly-created', assembly, fileIDs);\n\n      return _this3.connectSocket(assembly).then(function () {\n        return assembly;\n      });\n    }).then(function (assembly) {\n      _this3.uppy.log('[Transloadit] Created Assembly');\n      return assembly;\n    }).catch(function (err) {\n      _this3.uppy.info(_this3.i18n('creatingAssemblyFailed'), 'error', 0);\n\n      // Reject the promise.\n      throw err;\n    });\n  };\n\n  Transloadit.prototype.shouldWait = function shouldWait() {\n    return this.opts.waitForEncoding || this.opts.waitForMetadata;\n  };\n\n  /**\n   * Used when `importFromUploadURLs` is enabled: reserves all files in\n   * the assembly.\n   */\n\n\n  Transloadit.prototype.reserveFiles = function reserveFiles(assembly, fileIDs) {\n    var _this4 = this;\n\n    return _Promise.all(fileIDs.map(function (fileID) {\n      var file = _this4.uppy.getFile(fileID);\n      return _this4.client.reserveFile(assembly, file);\n    }));\n  };\n\n  /**\n   * Used when `importFromUploadURLs` is enabled: adds files to the assembly\n   * once they have been fully uploaded.\n   */\n\n\n  Transloadit.prototype.onFileUploadURLAvailable = function onFileUploadURLAvailable(file) {\n    var _this5 = this;\n\n    if (!file || !file.transloadit || !file.transloadit.assembly) {\n      return;\n    }\n\n    var state = this.getPluginState();\n    var assembly = state.assemblies[file.transloadit.assembly];\n\n    this.client.addFile(assembly, file).catch(function (err) {\n      _this5.uppy.log(err);\n      _this5.uppy.emit('transloadit:import-error', assembly, file.id, err);\n    });\n  };\n\n  Transloadit.prototype.findFile = function findFile(uploadedFile) {\n    var files = this.uppy.state.files;\n    for (var id in files) {\n      if (!files.hasOwnProperty(id)) {\n        continue;\n      }\n      // Completed file upload.\n      if (files[id].uploadURL === uploadedFile.tus_upload_url) {\n        return files[id];\n      }\n      // In-progress file upload.\n      if (files[id].tus && files[id].tus.uploadUrl === uploadedFile.tus_upload_url) {\n        return files[id];\n      }\n      if (!uploadedFile.is_tus_file) {\n        // Fingers-crossed check for non-tus uploads, eg imported from S3.\n        if (files[id].name === uploadedFile.name && files[id].size === uploadedFile.size) {\n          return files[id];\n        }\n      }\n    }\n  };\n\n  Transloadit.prototype.onFileUploadComplete = function onFileUploadComplete(assemblyId, uploadedFile) {\n    var _extends4;\n\n    var state = this.getPluginState();\n    var file = this.findFile(uploadedFile);\n    if (!file) {\n      this.uppy.log('[Transloadit] Couldn’t file the file, it was likely removed in the process');\n      return;\n    }\n    this.setPluginState({\n      files: _extends({}, state.files, (_extends4 = {}, _extends4[uploadedFile.id] = {\n        assembly: assemblyId,\n        id: file.id,\n        uploadedFile: uploadedFile\n      }, _extends4))\n    });\n    this.uppy.emit('transloadit:upload', uploadedFile, this.getAssembly(assemblyId));\n  };\n\n  Transloadit.prototype.onResult = function onResult(assemblyId, stepName, result) {\n    var state = this.getPluginState();\n    var file = state.files[result.original_id];\n    // The `file` may not exist if an import robot was used instead of a file upload.\n    result.localId = file ? file.id : null;\n\n    var entry = {\n      result: result,\n      stepName: stepName,\n      id: result.id,\n      assembly: assemblyId\n    };\n\n    this.setPluginState({\n      results: [].concat(state.results, [entry])\n    });\n    this.uppy.emit('transloadit:result', stepName, result, this.getAssembly(assemblyId));\n  };\n\n  Transloadit.prototype.onAssemblyFinished = function onAssemblyFinished(url) {\n    var _this6 = this;\n\n    this.client.getAssemblyStatus(url).then(function (assembly) {\n      var _extends5;\n\n      var state = _this6.getPluginState();\n      _this6.setPluginState({\n        assemblies: _extends({}, state.assemblies, (_extends5 = {}, _extends5[assembly.assembly_id] = assembly, _extends5))\n      });\n      _this6.uppy.emit('transloadit:complete', assembly);\n    });\n  };\n\n  Transloadit.prototype.getPersistentData = function getPersistentData(setData) {\n    var _setData;\n\n    var state = this.getPluginState();\n    var assemblies = state.assemblies;\n    var uploadsAssemblies = state.uploadsAssemblies;\n    var uploads = Object.keys(state.files);\n    var results = state.results.map(function (result) {\n      return result.id;\n    });\n\n    setData((_setData = {}, _setData[this.id] = {\n      assemblies: assemblies,\n      uploadsAssemblies: uploadsAssemblies,\n      uploads: uploads,\n      results: results\n    }, _setData));\n  };\n\n  /**\n   * Emit the necessary events that must have occured to get from the `prevState`,\n   * to the current state.\n   * For completed uploads, `transloadit:upload` is emitted.\n   * For new results, `transloadit:result` is emitted.\n   * For completed or errored assemblies, `transloadit:complete` or `transloadit:assembly-error` is emitted.\n   */\n\n\n  Transloadit.prototype.emitEventsDiff = function emitEventsDiff(prevState) {\n    var _this7 = this;\n\n    var opts = this.opts;\n    var state = this.getPluginState();\n\n    var emitMissedEvents = function emitMissedEvents() {\n      // Emit events for completed uploads and completed results\n      // that we've missed while we were away.\n      var newUploads = Object.keys(state.files).filter(function (fileID) {\n        return !prevState.files.hasOwnProperty(fileID);\n      }).map(function (fileID) {\n        return state.files[fileID];\n      });\n      var newResults = state.results.filter(function (result) {\n        return !prevState.results.some(function (prev) {\n          return prev.id === result.id;\n        });\n      });\n\n      _this7.uppy.log('[Transloadit] New fully uploaded files since restore:');\n      _this7.uppy.log(newUploads);\n      newUploads.forEach(function (_ref2) {\n        var assembly = _ref2.assembly,\n            uploadedFile = _ref2.uploadedFile;\n\n        _this7.uppy.log('[Transloadit]  emitting transloadit:upload ' + uploadedFile.id);\n        _this7.uppy.emit('transloadit:upload', uploadedFile, _this7.getAssembly(assembly));\n      });\n      _this7.uppy.log('[Transloadit] New results since restore:');\n      _this7.uppy.log(newResults);\n      newResults.forEach(function (_ref3) {\n        var assembly = _ref3.assembly,\n            stepName = _ref3.stepName,\n            result = _ref3.result,\n            id = _ref3.id;\n\n        _this7.uppy.log('[Transloadit]  emitting transloadit:result ' + stepName + ', ' + id);\n        _this7.uppy.emit('transloadit:result', stepName, result, _this7.getAssembly(assembly));\n      });\n\n      var newAssemblies = state.assemblies;\n      var previousAssemblies = prevState.assemblies;\n      _this7.uppy.log('[Transloadit] Current Assembly status after restore');\n      _this7.uppy.log(newAssemblies);\n      _this7.uppy.log('[Transloadit] Assembly status before restore');\n      _this7.uppy.log(previousAssemblies);\n      Object.keys(newAssemblies).forEach(function (assemblyId) {\n        var oldAssembly = previousAssemblies[assemblyId];\n        diffAssemblyStatus(oldAssembly, newAssemblies[assemblyId]);\n      });\n    };\n\n    // Emit events for assemblies that have completed or errored while we were away.\n    var diffAssemblyStatus = function diffAssemblyStatus(prev, next) {\n      _this7.uppy.log('[Transloadit] Diff assemblies');\n      _this7.uppy.log(prev);\n      _this7.uppy.log(next);\n\n      if (opts.waitForEncoding && next.ok === 'ASSEMBLY_COMPLETED' && prev.ok !== 'ASSEMBLY_COMPLETED') {\n        _this7.uppy.log('[Transloadit]  Emitting transloadit:complete for ' + next.assembly_id);\n        _this7.uppy.log(next);\n        _this7.uppy.emit('transloadit:complete', next);\n      } else if (opts.waitForMetadata && next.upload_meta_data_extracted && !prev.upload_meta_data_extracted) {\n        _this7.uppy.log('[Transloadit]  Emitting transloadit:complete after metadata extraction for ' + next.assembly_id);\n        _this7.uppy.log(next);\n        _this7.uppy.emit('transloadit:complete', next);\n      }\n\n      if (next.error && !prev.error) {\n        _this7.uppy.log('[Transloadit]  !!! Emitting transloadit:assembly-error for ' + next.assembly_id);\n        _this7.uppy.log(next);\n        _this7.uppy.emit('transloadit:assembly-error', next, new Error(next.message));\n      }\n    };\n\n    emitMissedEvents();\n  };\n\n  Transloadit.prototype.onRestored = function onRestored(pluginData) {\n    var _this8 = this;\n\n    var savedState = pluginData && pluginData[this.id] ? pluginData[this.id] : {};\n    var knownUploads = savedState.files || [];\n    var knownResults = savedState.results || [];\n    var previousAssemblies = savedState.assemblies || {};\n    var uploadsAssemblies = savedState.uploadsAssemblies || {};\n\n    if (Object.keys(uploadsAssemblies).length === 0) {\n      // Nothing to restore.\n      return;\n    }\n\n    // Fetch up-to-date assembly statuses.\n    var loadAssemblies = function loadAssemblies() {\n      var assemblyIDs = [];\n      Object.keys(uploadsAssemblies).forEach(function (uploadID) {\n        assemblyIDs.push.apply(assemblyIDs, uploadsAssemblies[uploadID]);\n      });\n\n      return _Promise.all(assemblyIDs.map(function (assemblyID) {\n        var url = 'https://api2.transloadit.com/assemblies/' + assemblyID;\n        return _this8.client.getAssemblyStatus(url);\n      }));\n    };\n\n    var reconnectSockets = function reconnectSockets(assemblies) {\n      return _Promise.all(assemblies.map(function (assembly) {\n        // No need to connect to the socket if the assembly has completed by now.\n        if (assembly.ok === 'ASSEMBLY_COMPLETE') {\n          return null;\n        }\n        return _this8.connectSocket(assembly);\n      }));\n    };\n\n    // Convert loaded assembly statuses to a Transloadit plugin state object.\n    var restoreState = function restoreState(assemblies) {\n      var assembliesById = {};\n      var files = {};\n      var results = [];\n      assemblies.forEach(function (assembly) {\n        assembliesById[assembly.assembly_id] = assembly;\n\n        assembly.uploads.forEach(function (uploadedFile) {\n          var file = _this8.findFile(uploadedFile);\n          files[uploadedFile.id] = {\n            id: file.id,\n            assembly: assembly.assembly_id,\n            uploadedFile: uploadedFile\n          };\n        });\n\n        var state = _this8.getPluginState();\n        Object.keys(assembly.results).forEach(function (stepName) {\n          assembly.results[stepName].forEach(function (result) {\n            var file = state.files[result.original_id];\n            result.localId = file ? file.id : null;\n            results.push({\n              id: result.id,\n              result: result,\n              stepName: stepName,\n              assembly: assembly.assembly_id\n            });\n          });\n        });\n      });\n\n      _this8.setPluginState({\n        assemblies: assembliesById,\n        files: files,\n        results: results,\n        uploadsAssemblies: uploadsAssemblies\n      });\n    };\n\n    // Restore all assembly state.\n    this.restored = _Promise.resolve().then(loadAssemblies).then(function (assemblies) {\n      restoreState(assemblies);\n      return reconnectSockets(assemblies);\n    }).then(function () {\n      // Return a callback that will be called by `afterUpload`\n      // once it has attached event listeners etc.\n      var newState = _this8.getPluginState();\n      var previousFiles = {};\n      knownUploads.forEach(function (id) {\n        previousFiles[id] = newState.files[id];\n      });\n      return function () {\n        return _this8.emitEventsDiff({\n          assemblies: previousAssemblies,\n          files: previousFiles,\n          results: newState.results.filter(function (_ref4) {\n            var id = _ref4.id;\n            return knownResults.indexOf(id) !== -1;\n          }),\n          uploadsAssemblies: uploadsAssemblies\n        });\n      };\n    });\n\n    this.restored.then(function () {\n      _this8.restored = null;\n    });\n  };\n\n  Transloadit.prototype.connectSocket = function connectSocket(assembly) {\n    var _this9 = this;\n\n    var socket = new StatusSocket(assembly.websocket_url, assembly);\n    this.sockets[assembly.assembly_id] = socket;\n\n    socket.on('upload', this.onFileUploadComplete.bind(this, assembly.assembly_id));\n    socket.on('error', function (error) {\n      _this9.uppy.emit('transloadit:assembly-error', assembly, error);\n    });\n\n    socket.on('executing', function () {\n      _this9.uppy.emit('transloadit:assembly-executing', assembly);\n    });\n\n    if (this.opts.waitForEncoding) {\n      socket.on('result', this.onResult.bind(this, assembly.assembly_id));\n    }\n\n    if (this.opts.waitForEncoding) {\n      socket.on('finished', function () {\n        _this9.onAssemblyFinished(assembly.assembly_ssl_url);\n      });\n    } else if (this.opts.waitForMetadata) {\n      socket.on('metadata', function () {\n        _this9.onAssemblyFinished(assembly.assembly_ssl_url);\n      });\n    }\n\n    return new _Promise(function (resolve, reject) {\n      socket.on('connect', resolve);\n      socket.on('error', reject);\n    }).then(function () {\n      _this9.uppy.log('[Transloadit] Socket is ready');\n    });\n  };\n\n  Transloadit.prototype.prepareUpload = function prepareUpload(fileIDs, uploadID) {\n    var _this10 = this,\n        _extends6;\n\n    // Only use files without errors\n    fileIDs = fileIDs.filter(function (file) {\n      return !file.error;\n    });\n\n    fileIDs.forEach(function (fileID) {\n      var file = _this10.uppy.getFile(fileID);\n      _this10.uppy.emit('preprocess-progress', file, {\n        mode: 'indeterminate',\n        message: _this10.i18n('creatingAssembly')\n      });\n    });\n\n    var createAssembly = function createAssembly(_ref5) {\n      var fileIDs = _ref5.fileIDs,\n          options = _ref5.options;\n\n      return _this10.createAssembly(fileIDs, uploadID, options).then(function (assembly) {\n        if (_this10.opts.importFromUploadURLs) {\n          return _this10.reserveFiles(assembly, fileIDs);\n        }\n      }).then(function () {\n        fileIDs.forEach(function (fileID) {\n          var file = _this10.uppy.getFile(fileID);\n          _this10.uppy.emit('preprocess-complete', file);\n        });\n      }).catch(function (err) {\n        // Clear preprocessing state when the assembly could not be created,\n        // otherwise the UI gets confused about the lingering progress keys\n        fileIDs.forEach(function (fileID) {\n          var file = _this10.uppy.getFile(fileID);\n          _this10.uppy.emit('preprocess-complete', file);\n          _this10.uppy.emit('upload-error', file, err);\n        });\n        throw err;\n      });\n    };\n\n    var state = this.getPluginState();\n    var uploadsAssemblies = _extends({}, state.uploadsAssemblies, (_extends6 = {}, _extends6[uploadID] = [], _extends6));\n    this.setPluginState({ uploadsAssemblies: uploadsAssemblies });\n\n    var optionsPromise = void 0;\n    if (fileIDs.length > 0) {\n      optionsPromise = this.getAssemblyOptions(fileIDs).then(function (allOptions) {\n        return _this10.dedupeAssemblyOptions(allOptions);\n      });\n    } else if (this.opts.alwaysRunAssembly) {\n      optionsPromise = _Promise.resolve(this.opts.getAssemblyOptions(null, this.opts)).then(function (options) {\n        _this10.validateParams(options.params);\n        return [{ fileIDs: fileIDs, options: options }];\n      });\n    } else {\n      // If there are no files and we do not `alwaysRunAssembly`,\n      // don't do anything.\n      return _Promise.resolve();\n    }\n\n    return optionsPromise.then(function (assemblies) {\n      return _Promise.all(assemblies.map(createAssembly));\n    });\n  };\n\n  Transloadit.prototype.afterUpload = function afterUpload(fileIDs, uploadID) {\n    var _this11 = this;\n\n    // Only use files without errors\n    fileIDs = fileIDs.filter(function (file) {\n      return !file.error;\n    });\n\n    var state = this.getPluginState();\n\n    // If we're still restoring state, wait for that to be done.\n    if (this.restored) {\n      return this.restored.then(function (emitMissedEvents) {\n        var promise = _this11.afterUpload(fileIDs, uploadID);\n        emitMissedEvents();\n        return promise;\n      });\n    }\n\n    var assemblyIDs = state.uploadsAssemblies[uploadID];\n\n    // If we don't have to wait for encoding metadata or results, we can close\n    // the socket immediately and finish the upload.\n    if (!this.shouldWait()) {\n      assemblyIDs.forEach(function (assemblyID) {\n        var socket = _this11.sockets[assemblyID];\n        socket.close();\n      });\n      var assemblies = assemblyIDs.map(function (id) {\n        return _this11.getAssembly(id);\n      });\n      this.uppy.addResultData(uploadID, { transloadit: assemblies });\n      return _Promise.resolve();\n    }\n\n    // If no assemblies were created for this upload, we also do not have to wait.\n    // There's also no sockets or anything to close, so just return immediately.\n    if (assemblyIDs.length === 0) {\n      this.uppy.addResultData(uploadID, { transloadit: [] });\n      return _Promise.resolve();\n    }\n\n    var finishedAssemblies = 0;\n\n    return new _Promise(function (resolve, reject) {\n      fileIDs.forEach(function (fileID) {\n        var file = _this11.uppy.getFile(fileID);\n        _this11.uppy.emit('postprocess-progress', file, {\n          mode: 'indeterminate',\n          message: _this11.i18n('encoding')\n        });\n      });\n\n      var onAssemblyFinished = function onAssemblyFinished(assembly) {\n        // An assembly for a different upload just finished. We can ignore it.\n        if (assemblyIDs.indexOf(assembly.assembly_id) === -1) {\n          _this11.uppy.log('[Transloadit] afterUpload(): Ignoring finished Assembly ' + assembly.assembly_id);\n          return;\n        }\n        _this11.uppy.log('[Transloadit] afterUpload(): Got Assembly finish ' + assembly.assembly_id);\n\n        // TODO set the `file.uploadURL` to a result?\n        // We will probably need an option here so the plugin user can tell us\n        // which result to pick…?\n\n        var files = _this11.getAssemblyFiles(assembly.assembly_id);\n        files.forEach(function (file) {\n          _this11.uppy.emit('postprocess-complete', file);\n        });\n\n        checkAllComplete();\n      };\n\n      var onAssemblyError = function onAssemblyError(assembly, error) {\n        // An assembly for a different upload just errored. We can ignore it.\n        if (assemblyIDs.indexOf(assembly.assembly_id) === -1) {\n          _this11.uppy.log('[Transloadit] afterUpload(): Ignoring errored Assembly ' + assembly.assembly_id);\n          return;\n        }\n        _this11.uppy.log('[Transloadit] afterUpload(): Got Assembly error ' + assembly.assembly_id);\n        _this11.uppy.log(error);\n\n        // Clear postprocessing state for all our files.\n        var files = _this11.getAssemblyFiles(assembly.assembly_id);\n        files.forEach(function (file) {\n          // TODO Maybe make a postprocess-error event here?\n          _this11.uppy.emit('upload-error', file, error);\n\n          _this11.uppy.emit('postprocess-complete', file);\n        });\n\n        checkAllComplete();\n      };\n\n      var onImportError = function onImportError(assembly, fileID, error) {\n        if (assemblyIDs.indexOf(assembly.assembly_id) === -1) {\n          return;\n        }\n\n        // Not sure if we should be doing something when it's just one file failing.\n        // ATM, the only options are 1) ignoring or 2) failing the entire upload.\n        // I think failing the upload is better than silently ignoring.\n        // In the future we should maybe have a way to resolve uploads with some failures,\n        // like returning an object with `{ successful, failed }` uploads.\n        onAssemblyError(assembly, error);\n      };\n\n      var checkAllComplete = function checkAllComplete() {\n        finishedAssemblies += 1;\n        if (finishedAssemblies === assemblyIDs.length) {\n          // We're done, these listeners can be removed\n          removeListeners();\n          var _assemblies = assemblyIDs.map(function (id) {\n            return _this11.getAssembly(id);\n          });\n          _this11.uppy.addResultData(uploadID, { transloadit: _assemblies });\n          resolve();\n        }\n      };\n\n      var removeListeners = function removeListeners() {\n        _this11.uppy.off('transloadit:complete', onAssemblyFinished);\n        _this11.uppy.off('transloadit:assembly-error', onAssemblyError);\n        _this11.uppy.off('transloadit:import-error', onImportError);\n      };\n\n      _this11.uppy.on('transloadit:complete', onAssemblyFinished);\n      _this11.uppy.on('transloadit:assembly-error', onAssemblyError);\n      _this11.uppy.on('transloadit:import-error', onImportError);\n    }).then(function (result) {\n      // Clean up uploadID → assemblyIDs, they're no longer going to be used anywhere.\n      var state = _this11.getPluginState();\n      var uploadsAssemblies = _extends({}, state.uploadsAssemblies);\n      delete uploadsAssemblies[uploadID];\n      _this11.setPluginState({ uploadsAssemblies: uploadsAssemblies });\n\n      return result;\n    });\n  };\n\n  Transloadit.prototype.install = function install() {\n    this.uppy.addPreProcessor(this.prepareUpload);\n    this.uppy.addPostProcessor(this.afterUpload);\n\n    if (this.opts.importFromUploadURLs) {\n      // No uploader needed when importing; instead we take the upload URL from an existing uploader.\n      this.uppy.on('upload-success', this.onFileUploadURLAvailable);\n    } else {\n      this.uppy.use(Tus, {\n        // Disable tus-js-client fingerprinting, otherwise uploading the same file at different times\n        // will upload to the same assembly.\n        resume: false,\n        // Only send assembly metadata to the tus endpoint.\n        metaFields: ['assembly_url', 'filename', 'fieldname']\n      });\n    }\n\n    this.uppy.on('restore:get-data', this.getPersistentData);\n    this.uppy.on('restored', this.onRestored);\n\n    this.setPluginState({\n      // Contains assembly status objects, indexed by their ID.\n      assemblies: {},\n      // Contains arrays of assembly IDs, indexed by the upload ID that they belong to.\n      uploadsAssemblies: {},\n      // Contains file data from Transloadit, indexed by their Transloadit-assigned ID.\n      files: {},\n      // Contains result data from Transloadit.\n      results: []\n    });\n  };\n\n  Transloadit.prototype.uninstall = function uninstall() {\n    this.uppy.removePreProcessor(this.prepareUpload);\n    this.uppy.removePostProcessor(this.afterUpload);\n\n    if (this.opts.importFromUploadURLs) {\n      this.uppy.off('upload-success', this.onFileUploadURLAvailable);\n    }\n  };\n\n  Transloadit.prototype.getAssembly = function getAssembly(id) {\n    var state = this.getPluginState();\n    return state.assemblies[id];\n  };\n\n  Transloadit.prototype.getAssemblyFiles = function getAssemblyFiles(assemblyID) {\n    var _this12 = this;\n\n    var fileIDs = Object.keys(this.uppy.state.files);\n    return fileIDs.map(function (fileID) {\n      return _this12.uppy.getFile(fileID);\n    }).filter(function (file) {\n      return file && file.transloadit && file.transloadit.assembly === assemblyID;\n    });\n  };\n\n  return Transloadit;\n}(Plugin);\n//# sourceMappingURL=index.js.map",null]}