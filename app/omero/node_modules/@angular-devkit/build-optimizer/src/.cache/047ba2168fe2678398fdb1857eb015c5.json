{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/ng2-tree/src/tree.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/ng2-tree/src/tree.js","mtime":1528354008000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar fn_utils_1 = require('./utils/fn.utils');\nvar Observable_1 = require('rxjs/Observable');\nvar tree_types_1 = require('./tree.types');\nvar uuidv4 = require('uuid/v4');\nvar ChildrenLoadingState;\n(function(ChildrenLoadingState) {\n  ChildrenLoadingState[(ChildrenLoadingState['NotStarted'] = 0)] = 'NotStarted';\n  ChildrenLoadingState[(ChildrenLoadingState['Loading'] = 1)] = 'Loading';\n  ChildrenLoadingState[(ChildrenLoadingState['Completed'] = 2)] = 'Completed';\n})(ChildrenLoadingState || (ChildrenLoadingState = {}));\nvar Tree = (function() {\n  /**\n   * Build an instance of Tree from an object implementing TreeModel interface.\n   * @param {TreeModel} model - A model that is used to build a tree.\n   * @param {Tree} [parent] - An optional parent if you want to build a tree from the model that should be a child of an existing Tree instance.\n   * @param {boolean} [isBranch] - An option that makes a branch from created tree. Branch can have children.\n   */\n  function Tree(node, parent, isBranch) {\n    if (parent === void 0) {\n      parent = null;\n    }\n    if (isBranch === void 0) {\n      isBranch = false;\n    }\n    var _this = this;\n    this._childrenLoadingState = ChildrenLoadingState.NotStarted;\n    this._childrenAsyncOnce = fn_utils_1.once(function() {\n      return new Observable_1.Observable(function(observer) {\n        setTimeout(function() {\n          _this._childrenLoadingState = ChildrenLoadingState.Loading;\n          _this._loadChildren(function(children) {\n            _this._children = (children || []).map(function(child) {\n              return new Tree(child, _this);\n            });\n            _this._childrenLoadingState = ChildrenLoadingState.Completed;\n            observer.next(_this.children);\n            observer.complete();\n          });\n        });\n      });\n    });\n    this.buildTreeFromModel(node, parent, isBranch || Array.isArray(node.children));\n  }\n  // STATIC METHODS ----------------------------------------------------------------------------------------------------\n  /**\n   * Check that value passed is not empty (it doesn't consist of only whitespace symbols).\n   * @param {string} value - A value that should be checked.\n   * @returns {boolean} - A flag indicating that value is empty or not.\n   * @static\n   */\n  Tree.isValueEmpty = function(value) {\n    return fn_utils_1.isEmpty(fn_utils_1.trim(value));\n  };\n  /**\n   * Check whether a given value can be considered RenamableNode.\n   * @param {any} value - A value to check.\n   * @returns {boolean} - A flag indicating whether given value is Renamable node or not.\n   * @static\n   */\n  Tree.isRenamable = function(value) {\n    return (\n      fn_utils_1.has(value, 'setName') &&\n      fn_utils_1.isFunction(value.setName) &&\n      (fn_utils_1.has(value, 'toString') && fn_utils_1.isFunction(value.toString) && value.toString !== Object.toString)\n    );\n  };\n  Tree.cloneTreeShallow = function(origin) {\n    var tree = new Tree(Object.assign({}, origin.node));\n    tree._children = origin._children;\n    return tree;\n  };\n  Tree.applyNewValueToRenamable = function(value, newValue) {\n    var renamableValue = Object.assign({}, value);\n    renamableValue.setName(newValue);\n    return renamableValue;\n  };\n  Tree.prototype.buildTreeFromModel = function(model, parent, isBranch) {\n    var _this = this;\n    this.parent = parent;\n    this.node = Object.assign(\n      fn_utils_1.omit(model, 'children'),\n      { settings: tree_types_1.TreeModelSettings.merge(model, fn_utils_1.get(parent, 'node')) },\n      { emitLoadNextLevel: model.emitLoadNextLevel === true }\n    );\n    if (fn_utils_1.isFunction(this.node.loadChildren)) {\n      this._loadChildren = this.node.loadChildren;\n    } else {\n      fn_utils_1.get(model, 'children', []).forEach(function(child, index) {\n        _this._addChild(new Tree(child, _this), index);\n      });\n    }\n    if (!Array.isArray(this._children)) {\n      this._children = this.node.loadChildren || isBranch ? [] : null;\n    }\n  };\n  Tree.prototype.hasDeferredChildren = function() {\n    return typeof this._loadChildren === 'function';\n  };\n  /* Setting the children loading state to Loading since a request was dispatched to the client */\n  Tree.prototype.loadingChildrenRequested = function() {\n    this._childrenLoadingState = ChildrenLoadingState.Loading;\n  };\n  /**\n   * Check whether children of the node are being loaded.\n   * Makes sense only for nodes that define `loadChildren` function.\n   * @returns {boolean} A flag indicating that children are being loaded.\n   */\n  Tree.prototype.childrenAreBeingLoaded = function() {\n    return this._childrenLoadingState === ChildrenLoadingState.Loading;\n  };\n  /**\n   * Check whether children of the node were loaded.\n   * Makes sense only for nodes that define `loadChildren` function.\n   * @returns {boolean} A flag indicating that children were loaded.\n   */\n  Tree.prototype.childrenWereLoaded = function() {\n    return this._childrenLoadingState === ChildrenLoadingState.Completed;\n  };\n  Tree.prototype.canLoadChildren = function() {\n    return (\n      this._childrenLoadingState === ChildrenLoadingState.NotStarted &&\n      this.foldingType === tree_types_1.FoldingType.Expanded &&\n      !!this._loadChildren\n    );\n  };\n  /**\n   * Check whether children of the node should be loaded and not loaded yet.\n   * Makes sense only for nodes that define `loadChildren` function.\n   * @returns {boolean} A flag indicating that children should be loaded for the current node.\n   */\n  Tree.prototype.childrenShouldBeLoaded = function() {\n    return !this.childrenWereLoaded() && (!!this._loadChildren || this.node.emitLoadNextLevel === true);\n  };\n  Object.defineProperty(Tree.prototype, 'children', {\n    /**\n     * Get children of the current tree.\n     * @returns {Tree[]} The children of the current tree.\n     */\n    get: function() {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tree.prototype, 'childrenAsync', {\n    /**\n     * By getting value from this property you start process of loading node's children using `loadChildren` function.\n     * Once children are loaded `loadChildren` function won't be called anymore and loaded for the first time children are emitted in case of subsequent calls.\n     * @returns {Observable<Tree[]>} An observable which emits children once they are loaded.\n     */\n    get: function() {\n      if (this.canLoadChildren()) {\n        return this._childrenAsyncOnce();\n      }\n      return Observable_1.Observable.of(this.children);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * By calling this method you start process of loading node's children using `loadChildren` function.\n   */\n  Tree.prototype.reloadChildren = function() {\n    var _this = this;\n    if (this.childrenShouldBeLoaded()) {\n      this._childrenLoadingState = ChildrenLoadingState.Loading;\n      this._loadChildren(function(children) {\n        _this._children =\n          children &&\n          children.map(function(child) {\n            return new Tree(child, _this);\n          });\n        _this._childrenLoadingState = ChildrenLoadingState.Completed;\n      });\n    }\n  };\n  /**\n   * By calling this method you will remove all current children of a treee and create new.\n   */\n  Tree.prototype.setChildren = function(children) {\n    var _this = this;\n    this._children =\n      children &&\n      children.map(function(child) {\n        return new Tree(child, _this);\n      });\n    if (this.childrenShouldBeLoaded()) {\n      this._childrenLoadingState = ChildrenLoadingState.Completed;\n    }\n  };\n  /**\n   * Create a new node in the current tree.\n   * @param {boolean} isBranch - A flag that indicates whether a new node should be a \"Branch\". \"Leaf\" node will be created by default\n   * @param {TreeModel} model - Tree model of the new node which will be inserted. Empty node will be created by default and it will fire edit mode of this node\n   * @returns {Tree} A newly created child node.\n   */\n  Tree.prototype.createNode = function(isBranch, model) {\n    if (model === void 0) {\n      model = { value: '' };\n    }\n    var tree = new Tree(model, this, isBranch);\n    if (!model.id) {\n      tree.markAsNew();\n    }\n    tree.id = tree.id || uuidv4();\n    if (this.childrenShouldBeLoaded() && !(this.childrenAreBeingLoaded() || this.childrenWereLoaded())) {\n      return null;\n    }\n    if (this.isLeaf()) {\n      return this.addSibling(tree);\n    } else {\n      return this.addChild(tree);\n    }\n  };\n  Object.defineProperty(Tree.prototype, 'value', {\n    /**\n     * Get the value of the current node\n     * @returns {(string|RenamableNode)} The value of the node.\n     */\n    get: function() {\n      return this.node.value;\n    },\n    /**\n     * Set the value of the current node\n     * @param {(string|RenamableNode)} value - The new value of the node.\n     */\n    set: function(value) {\n      if (typeof value !== 'string' && !Tree.isRenamable(value)) {\n        return;\n      }\n      var stringifiedValue = '' + value;\n      if (Tree.isRenamable(this.value)) {\n        this.node.value = Tree.applyNewValueToRenamable(this.value, stringifiedValue);\n      } else {\n        this.node.value = Tree.isValueEmpty(stringifiedValue) ? this.node.value : stringifiedValue;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tree.prototype, 'checked', {\n    get: function() {\n      return !!fn_utils_1.get(this.node.settings, 'checked');\n    },\n    set: function(checked) {\n      this.node.settings = Object.assign({}, this.node.settings, { checked: checked });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tree.prototype, 'checkedChildren', {\n    get: function() {\n      return this.hasLoadedChildern()\n        ? this.children.filter(function(child) {\n            return child.checked;\n          })\n        : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tree.prototype, 'selectionAllowed', {\n    get: function() {\n      var value = fn_utils_1.get(this.node.settings, 'selectionAllowed');\n      return fn_utils_1.isNil(value) ? true : !!value;\n    },\n    set: function(selectionAllowed) {\n      this.node.settings = Object.assign({}, this.node.settings, { selectionAllowed: selectionAllowed });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Tree.prototype.hasLoadedChildern = function() {\n    return !fn_utils_1.isEmpty(this.children);\n  };\n  Tree.prototype.loadedChildrenAmount = function() {\n    return fn_utils_1.size(this.children);\n  };\n  Tree.prototype.checkedChildrenAmount = function() {\n    return fn_utils_1.size(this.checkedChildren);\n  };\n  /**\n   * Add a sibling node for the current node. This won't work if the current node is a root.\n   * @param {Tree} sibling - A node that should become a sibling.\n   * @param [number] position - Position in which sibling will be inserted. By default it will be inserted at the last position in a parent.\n   * @returns {Tree} A newly inserted sibling, or null if you are trying to make a sibling for the root.\n   */\n  Tree.prototype.addSibling = function(sibling, position) {\n    if (Array.isArray(fn_utils_1.get(this.parent, 'children'))) {\n      return this.parent.addChild(sibling, position);\n    }\n    return null;\n  };\n  /**\n   * Add a child node for the current node.\n   * @param {Tree} child - A node that should become a child.\n   * @param [number] position - Position in which child will be inserted. By default it will be inserted at the last position in a parent.\n   * @returns {Tree} A newly inserted child.\n   */\n  Tree.prototype.addChild = function(child, position) {\n    var newborn = this._addChild(Tree.cloneTreeShallow(child), position);\n    this._setFoldingType();\n    if (this.isNodeCollapsed()) {\n      this.switchFoldingType();\n    }\n    return newborn;\n  };\n  Tree.prototype._addChild = function(child, position) {\n    if (position === void 0) {\n      position = fn_utils_1.size(this._children) || 0;\n    }\n    child.parent = this;\n    if (Array.isArray(this._children)) {\n      this._children.splice(position, 0, child);\n    } else {\n      this._children = [child];\n    }\n    return child;\n  };\n  /**\n   * Swap position of the current node with the given sibling. If node passed as a parameter is not a sibling - nothing happens.\n   * @param {Tree} sibling - A sibling with which current node shold be swapped.\n   */\n  Tree.prototype.swapWithSibling = function(sibling) {\n    if (!this.hasSibling(sibling)) {\n      return;\n    }\n    var siblingIndex = sibling.positionInParent;\n    var thisTreeIndex = this.positionInParent;\n    this.parent._children[siblingIndex] = this;\n    this.parent._children[thisTreeIndex] = sibling;\n  };\n  Object.defineProperty(Tree.prototype, 'positionInParent', {\n    /**\n     * Get a node's position in its parent.\n     * @returns {number} The position inside a parent.\n     */\n    get: function() {\n      if (this.isRoot()) {\n        return -1;\n      }\n      return this.parent.children ? this.parent.children.indexOf(this) : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Check whether or not this tree is static.\n   * @returns {boolean} A flag indicating whether or not this tree is static.\n   */\n  Tree.prototype.isStatic = function() {\n    return fn_utils_1.get(this.node.settings, 'static', false);\n  };\n  /**\n   * Check whether or not this tree has a left menu.\n   * @returns {boolean} A flag indicating whether or not this tree has a left menu.\n   */\n  Tree.prototype.hasLeftMenu = function() {\n    return (\n      !fn_utils_1.get(this.node.settings, 'static', false) && fn_utils_1.get(this.node.settings, 'leftMenu', false)\n    );\n  };\n  /**\n   * Check whether or not this tree has a right menu.\n   * @returns {boolean} A flag indicating whether or not this tree has a right menu.\n   */\n  Tree.prototype.hasRightMenu = function() {\n    return (\n      !fn_utils_1.get(this.node.settings, 'static', false) && fn_utils_1.get(this.node.settings, 'rightMenu', false)\n    );\n  };\n  /**\n   * Check whether this tree is \"Leaf\" or not.\n   * @returns {boolean} A flag indicating whether or not this tree is a \"Leaf\".\n   */\n  Tree.prototype.isLeaf = function() {\n    return !this.isBranch();\n  };\n  Object.defineProperty(Tree.prototype, 'menuItems', {\n    /**\n     * Get menu items of the current tree.\n     * @returns {NodeMenuItem[]} The menu items of the current tree.\n     */\n    get: function() {\n      return fn_utils_1.get(this.node.settings, 'menuItems');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Check whether or not this tree has a custom menu.\n   * @returns {boolean} A flag indicating whether or not this tree has a custom menu.\n   */\n  Tree.prototype.hasCustomMenu = function() {\n    return !this.isStatic() && !!fn_utils_1.get(this.node.settings, 'menuItems', false);\n  };\n  /**\n   * Check whether this tree is \"Branch\" or not. \"Branch\" is a node that has children.\n   * @returns {boolean} A flag indicating whether or not this tree is a \"Branch\".\n   */\n  Tree.prototype.isBranch = function() {\n    return this.node.emitLoadNextLevel === true || Array.isArray(this._children);\n  };\n  /**\n   * Check whether this tree has children.\n   * @returns {boolean} A flag indicating whether or not this tree has children.\n   */\n  Tree.prototype.hasChildren = function() {\n    return !fn_utils_1.isEmpty(this._children) || this.childrenShouldBeLoaded();\n  };\n  /**\n   * Check whether this tree is a root or not. The root is the tree (node) that doesn't have parent (or technically its parent is null).\n   * @returns {boolean} A flag indicating whether or not this tree is the root.\n   */\n  Tree.prototype.isRoot = function() {\n    return fn_utils_1.isNil(this.parent);\n  };\n  /**\n   * Check whether provided tree is a sibling of the current tree. Sibling trees (nodes) are the trees that have the same parent.\n   * @param {Tree} tree - A tree that should be tested on a siblingness.\n   * @returns {boolean} A flag indicating whether or not provided tree is the sibling of the current one.\n   */\n  Tree.prototype.hasSibling = function(tree) {\n    return !this.isRoot() && fn_utils_1.includes(this.parent.children, tree);\n  };\n  /**\n   * Check whether provided tree is a child of the current tree.\n   * This method tests that provided tree is a <strong>direct</strong> child of the current tree.\n   * @param {Tree} tree - A tree that should be tested (child candidate).\n   * @returns {boolean} A flag indicating whether provided tree is a child or not.\n   */\n  Tree.prototype.hasChild = function(tree) {\n    return fn_utils_1.includes(this._children, tree);\n  };\n  /**\n   * Remove given tree from the current tree.\n   * The given tree will be removed only in case it is a direct child of the current tree (@see {@link hasChild}).\n   * @param {Tree} tree - A tree that should be removed.\n   */\n  Tree.prototype.removeChild = function(tree) {\n    if (!this.hasChildren()) {\n      return;\n    }\n    var childIndex = this._children.findIndex(function(child) {\n      return child === tree;\n    });\n    if (childIndex >= 0) {\n      this._children.splice(childIndex, 1);\n    }\n    this._setFoldingType();\n  };\n  /**\n   * Remove current tree from its parent.\n   */\n  Tree.prototype.removeItselfFromParent = function() {\n    if (!this.parent) {\n      return;\n    }\n    this.parent.removeChild(this);\n  };\n  /**\n   * Switch folding type of the current tree. \"Leaf\" node cannot switch its folding type cause it doesn't have children, hence nothing to fold.\n   * If node is a \"Branch\" and it is expanded, then by invoking current method state of the tree should be switched to \"collapsed\" and vice versa.\n   */\n  Tree.prototype.switchFoldingType = function() {\n    if (this.isLeaf() || !this.hasChildren()) {\n      return;\n    }\n    this.disableCollapseOnInit();\n    this.node._foldingType = this.isNodeExpanded()\n      ? tree_types_1.FoldingType.Collapsed\n      : tree_types_1.FoldingType.Expanded;\n  };\n  /**\n   * Check that tree is expanded.\n   * @returns {boolean} A flag indicating whether current tree is expanded. Always returns false for the \"Leaf\" tree and for an empty tree.\n   */\n  Tree.prototype.isNodeExpanded = function() {\n    return this.foldingType === tree_types_1.FoldingType.Expanded;\n  };\n  /**\n   * Check that tree is collapsed.\n   * @returns {boolean} A flag indicating whether current tree is collapsed. Always returns false for the \"Leaf\" tree and for an empty tree.\n   */\n  Tree.prototype.isNodeCollapsed = function() {\n    return this.foldingType === tree_types_1.FoldingType.Collapsed;\n  };\n  /**\n   * Set a current folding type: expanded, collapsed or leaf.\n   */\n  Tree.prototype._setFoldingType = function() {\n    if (this.childrenShouldBeLoaded()) {\n      this.node._foldingType = tree_types_1.FoldingType.Collapsed;\n    } else if (this._children && !fn_utils_1.isEmpty(this._children)) {\n      this.node._foldingType = this.isCollapsedOnInit()\n        ? tree_types_1.FoldingType.Collapsed\n        : tree_types_1.FoldingType.Expanded;\n    } else if (Array.isArray(this._children)) {\n      this.node._foldingType = tree_types_1.FoldingType.Empty;\n    } else {\n      this.node._foldingType = tree_types_1.FoldingType.Leaf;\n    }\n  };\n  Object.defineProperty(Tree.prototype, 'foldingType', {\n    /**\n     * Get a current folding type: expanded, collapsed or leaf.\n     * @returns {FoldingType} A folding type of the current tree.\n     */\n    get: function() {\n      if (!this.node._foldingType) {\n        this._setFoldingType();\n      }\n      return this.node._foldingType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tree.prototype, 'foldingCssClass', {\n    /**\n     * Get a css class for element which displayes folding state - expanded, collapsed or leaf\n     * @returns {string} A string icontaining css class (classes)\n     */\n    get: function() {\n      return this.getCssClassesFromSettings() || this.foldingType.cssClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Tree.prototype.getCssClassesFromSettings = function() {\n    if (!this.node._foldingType) {\n      this._setFoldingType();\n    }\n    if (this.node._foldingType === tree_types_1.FoldingType.Collapsed) {\n      return fn_utils_1.get(this.node.settings, 'cssClasses.collapsed', null);\n    } else if (this.node._foldingType === tree_types_1.FoldingType.Expanded) {\n      return fn_utils_1.get(this.node.settings, 'cssClasses.expanded', null);\n    } else if (this.node._foldingType === tree_types_1.FoldingType.Empty) {\n      return fn_utils_1.get(this.node.settings, 'cssClasses.empty', null);\n    }\n    return fn_utils_1.get(this.node.settings, 'cssClasses.leaf', null);\n  };\n  Object.defineProperty(Tree.prototype, 'nodeTemplate', {\n    /**\n     * Get a html template to render before every node's name.\n     * @returns {string} A string representing a html template.\n     */\n    get: function() {\n      return this.getTemplateFromSettings();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Tree.prototype.getTemplateFromSettings = function() {\n    if (this.isLeaf()) {\n      return fn_utils_1.get(this.node.settings, 'templates.leaf', '');\n    } else {\n      return fn_utils_1.get(this.node.settings, 'templates.node', '');\n    }\n  };\n  Object.defineProperty(Tree.prototype, 'leftMenuTemplate', {\n    /**\n     * Get a html template to render for an element activatin left menu of a node.\n     * @returns {string} A string representing a html template.\n     */\n    get: function() {\n      if (this.hasLeftMenu()) {\n        return fn_utils_1.get(this.node.settings, 'templates.leftMenu', '<span></span>');\n      }\n      return '';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Tree.prototype.disableCollapseOnInit = function() {\n    if (this.node.settings) {\n      this.node.settings.isCollapsedOnInit = false;\n    }\n  };\n  Tree.prototype.isCollapsedOnInit = function() {\n    return !!fn_utils_1.get(this.node.settings, 'isCollapsedOnInit');\n  };\n  Tree.prototype.keepNodesInDOM = function() {\n    return fn_utils_1.get(this.node.settings, 'keepNodesInDOM');\n  };\n  /**\n   * Check that current tree is newly created (added by user via menu for example). Tree that was built from the TreeModel is not marked as new.\n   * @returns {boolean} A flag whether the tree is new.\n   */\n  Tree.prototype.isNew = function() {\n    return this.node._status === tree_types_1.TreeStatus.New;\n  };\n  Object.defineProperty(Tree.prototype, 'id', {\n    get: function() {\n      return fn_utils_1.get(this.node, 'id');\n    },\n    set: function(id) {\n      this.node.id = id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Mark current tree as new (@see {@link isNew}).\n   */\n  Tree.prototype.markAsNew = function() {\n    this.node._status = tree_types_1.TreeStatus.New;\n  };\n  /**\n   * Check that current tree is being renamed (it is in the process of its value renaming initiated by a user).\n   * @returns {boolean} A flag whether the tree is being renamed.\n   */\n  Tree.prototype.isBeingRenamed = function() {\n    return this.node._status === tree_types_1.TreeStatus.IsBeingRenamed;\n  };\n  /**\n   * Mark current tree as being renamed (@see {@link isBeingRenamed}).\n   */\n  Tree.prototype.markAsBeingRenamed = function() {\n    this.node._status = tree_types_1.TreeStatus.IsBeingRenamed;\n  };\n  /**\n   * Check that current tree is modified (for example it was renamed).\n   * @returns {boolean} A flag whether the tree is modified.\n   */\n  Tree.prototype.isModified = function() {\n    return this.node._status === tree_types_1.TreeStatus.Modified;\n  };\n  /**\n   * Mark current tree as modified (@see {@link isModified}).\n   */\n  Tree.prototype.markAsModified = function() {\n    this.node._status = tree_types_1.TreeStatus.Modified;\n  };\n  /**\n   * Makes a clone of an underlying TreeModel instance\n   * @returns {TreeModel} a clone of an underlying TreeModel instance\n   */\n  Tree.prototype.toTreeModel = function() {\n    var model = fn_utils_1.defaultsDeep(this.isLeaf() ? {} : { children: [] }, this.node);\n    if (this.children) {\n      this.children.forEach(function(child) {\n        model.children.push(child.toTreeModel());\n      });\n    }\n    return model;\n  };\n  return Tree;\n})();\nexports.Tree = Tree;\n//# sourceMappingURL=tree.js.map\n",null]}