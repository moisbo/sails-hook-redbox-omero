{"remainingRequest":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/GoldenRetriever/IndexedDBStore.js","dependencies":[{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/uppy/lib/plugins/GoldenRetriever/IndexedDBStore.js","mtime":1521677672000},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/cache-loader/dist/cjs.js","mtime":1528352013145},{"path":"/Users/moises/source/code.research/sails-hook-redbox-omero/app/omero/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;\n\nvar prettyBytes = require('prettier-bytes');\nvar indexedDB = typeof window !== 'undefined' && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB);\n\nvar isSupported = !!indexedDB;\n\nvar DB_NAME = 'uppy-blobs';\nvar STORE_NAME = 'files'; // maybe have a thumbnail store in the future\nvar DEFAULT_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours\nvar DB_VERSION = 3;\n\n// Set default `expires` dates on existing stored blobs.\nfunction migrateExpiration(store) {\n  var request = store.openCursor();\n  request.onsuccess = function (event) {\n    var cursor = event.target.result;\n    if (!cursor) {\n      return;\n    }\n    var entry = cursor.value;\n    entry.expires = Date.now() + DEFAULT_EXPIRY;\n    cursor.update(entry);\n  };\n}\n\nfunction connect(dbName) {\n  var request = indexedDB.open(dbName, DB_VERSION);\n  return new _Promise(function (resolve, reject) {\n    request.onupgradeneeded = function (event) {\n      var db = event.target.result;\n      var transaction = event.currentTarget.transaction;\n\n      if (event.oldVersion < 2) {\n        // Added in v2: DB structure changed to a single shared object store\n        var store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n        store.createIndex('store', 'store', { unique: false });\n      }\n\n      if (event.oldVersion < 3) {\n        // Added in v3\n        var _store = transaction.objectStore(STORE_NAME);\n        _store.createIndex('expires', 'expires', { unique: false });\n\n        migrateExpiration(_store);\n      }\n\n      transaction.oncomplete = function () {\n        resolve(db);\n      };\n    };\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n    request.onerror = reject;\n  });\n}\n\nfunction waitForRequest(request) {\n  return new _Promise(function (resolve, reject) {\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n    request.onerror = reject;\n  });\n}\n\nvar cleanedUp = false;\n\nvar IndexedDBStore = function () {\n  function IndexedDBStore(opts) {\n    var _this = this;\n\n    _classCallCheck(this, IndexedDBStore);\n\n    this.opts = _extends({\n      dbName: DB_NAME,\n      storeName: 'default',\n      expires: DEFAULT_EXPIRY, // 24 hours\n      maxFileSize: 10 * 1024 * 1024, // 10 MB\n      maxTotalSize: 300 * 1024 * 1024 // 300 MB\n    }, opts);\n\n    this.name = this.opts.storeName;\n\n    var createConnection = function createConnection() {\n      return connect(_this.opts.dbName);\n    };\n\n    if (!cleanedUp) {\n      cleanedUp = true;\n      this.ready = IndexedDBStore.cleanup().then(createConnection, createConnection);\n    } else {\n      this.ready = createConnection();\n    }\n  }\n\n  IndexedDBStore.prototype.key = function key(fileID) {\n    return this.name + '!' + fileID;\n  };\n\n  /**\n   * List all file blobs currently in the store.\n   */\n\n\n  IndexedDBStore.prototype.list = function list() {\n    var _this2 = this;\n\n    return this.ready.then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readonly');\n      var store = transaction.objectStore(STORE_NAME);\n      var request = store.index('store').getAll(IDBKeyRange.only(_this2.name));\n      return waitForRequest(request);\n    }).then(function (files) {\n      var result = {};\n      files.forEach(function (file) {\n        result[file.fileID] = file.data;\n      });\n      return result;\n    });\n  };\n\n  /**\n   * Get one file blob from the store.\n   */\n\n\n  IndexedDBStore.prototype.get = function get(fileID) {\n    var _this3 = this;\n\n    return this.ready.then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readonly');\n      var request = transaction.objectStore(STORE_NAME).get(_this3.key(fileID));\n      return waitForRequest(request);\n    }).then(function (result) {\n      return {\n        id: result.data.fileID,\n        data: result.data.data\n      };\n    });\n  };\n\n  /**\n   * Get the total size of all stored files.\n   *\n   * @private\n   */\n\n\n  IndexedDBStore.prototype.getSize = function getSize() {\n    var _this4 = this;\n\n    return this.ready.then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readonly');\n      var store = transaction.objectStore(STORE_NAME);\n      var request = store.index('store').openCursor(IDBKeyRange.only(_this4.name));\n      return new _Promise(function (resolve, reject) {\n        var size = 0;\n        request.onsuccess = function (event) {\n          var cursor = event.target.result;\n          if (cursor) {\n            size += cursor.value.data.size;\n            cursor.continue();\n          } else {\n            resolve(size);\n          }\n        };\n        request.onerror = function () {\n          reject(new Error('Could not retrieve stored blobs size'));\n        };\n      });\n    });\n  };\n\n  /**\n   * Save a file in the store.\n   */\n\n\n  IndexedDBStore.prototype.put = function put(file) {\n    var _this5 = this;\n\n    if (file.data.size > this.opts.maxFileSize) {\n      return _Promise.reject(new Error('File is too big to store.'));\n    }\n    return this.getSize().then(function (size) {\n      if (size > _this5.opts.maxTotalSize) {\n        return _Promise.reject(new Error('No space left'));\n      }\n      return _this5.ready;\n    }).then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readwrite');\n      var request = transaction.objectStore(STORE_NAME).add({\n        id: _this5.key(file.id),\n        fileID: file.id,\n        store: _this5.name,\n        expires: Date.now() + _this5.opts.expires,\n        data: file.data\n      });\n      return waitForRequest(request);\n    });\n  };\n\n  /**\n   * Delete a file blob from the store.\n   */\n\n\n  IndexedDBStore.prototype.delete = function _delete(fileID) {\n    var _this6 = this;\n\n    return this.ready.then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readwrite');\n      var request = transaction.objectStore(STORE_NAME).delete(_this6.key(fileID));\n      return waitForRequest(request);\n    });\n  };\n\n  /**\n   * Delete all stored blobs that have an expiry date that is before Date.now().\n   * This is a static method because it deletes expired blobs from _all_ Uppy instances.\n   */\n\n\n  IndexedDBStore.cleanup = function cleanup() {\n    return connect(DB_NAME).then(function (db) {\n      var transaction = db.transaction([STORE_NAME], 'readwrite');\n      var store = transaction.objectStore(STORE_NAME);\n      var request = store.index('expires').openCursor(IDBKeyRange.upperBound(Date.now()));\n      return new _Promise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n          var cursor = event.target.result;\n          if (cursor) {\n            var entry = cursor.value;\n            console.log('[IndexedDBStore] Deleting record', entry.fileID, 'of size', prettyBytes(entry.data.size), '- expired on', new Date(entry.expires));\n            cursor.delete(); // Ignoring return value â€¦ it's not terrible if this goes wrong.\n            cursor.continue();\n          } else {\n            resolve(db);\n          }\n        };\n        request.onerror = reject;\n      });\n    }).then(function (db) {\n      db.close();\n    });\n  };\n\n  return IndexedDBStore;\n}();\n\nIndexedDBStore.isSupported = isSupported;\n\nmodule.exports = IndexedDBStore;\n//# sourceMappingURL=IndexedDBStore.js.map",null]}